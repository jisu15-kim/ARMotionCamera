//
//  ViewController.swift
//  ARKitExample
//
//  Created by ÍπÄÏßÄÏàò on 2023/05/08.
//

import UIKit
import RxSwift
import RxCocoa
import RealityKit
import ARKit
import SnapKit

class ARViewController: UIViewController {
    //MARK: - Properties
    var planeEntities: [ARAnchor : ModelEntity] = [:]

    let viewModel: ARViewModel
    var disposeBag = DisposeBag()
    var arView = ARView(frame: .zero)
    
    let scanningDebugToggle: UISwitch = {
        let toggle = UISwitch()
        toggle.isOn = false
        return toggle
    }()
    
    let debugLabel: UILabel = {
        let label = UILabel()
        label.font = .systemFont(ofSize: 16, weight: .medium)
        label.textColor = .white
        label.textAlignment = .center
        label.text = "N/A"
        label.numberOfLines = 0
        return label
    }()
    
    lazy var debugView: UIView = {
        let view = UIView()
        view.backgroundColor = .black.withAlphaComponent(0.4)
        view.addSubview(debugLabel)
        debugLabel.snp.makeConstraints {
            $0.centerX.centerY.equalToSuperview()
        }
        return view
    }()
    
    let resetButton: UIButton = {
        let button = UIButton(type: .system)
        button.setTitle("üïπÔ∏èReset", for: .normal)
        button.tintColor = .white
        button.backgroundColor = .systemIndigo
        return button
    }()

    var modelsForClassification: [ARMeshClassification: ModelEntity] = [:]
    
    //MARK: - LifeCycle
    init(viewModel: ARViewModel) {
        self.viewModel = viewModel
        super.init(nibName: nil, bundle: nil)
    }
    
    required init?(coder: NSCoder) {
        fatalError("init(coder:) has not been implemented")
    }
    
    override func viewDidLoad() {
        super.viewDidLoad()
        
        setupUI()
        bind()
        setupARKit()
    }
        
    //MARK: - Bind
    private func bind() {
        
        scanningDebugToggle.rx.isOn
            .bind { [weak self] bool in
                if bool == true {
                    self?.arView.debugOptions.insert(.showSceneUnderstanding)
                } else {
                    self?.arView.debugOptions.remove(.showSceneUnderstanding)
                }
            }
            .disposed(by: disposeBag)
        
        viewModel.motionData
            .bind { [weak self] data in
                guard let self = self else { return }
                
                let positionX = data.position.x.formatToSecond
                let positionY = data.position.y.formatToSecond
                let positionZ = data.position.z.formatToSecond
                let rotationX = data.rotation.x.formatToSecond
                let rotationY = data.rotation.y.formatToSecond
                let rotationZ = data.rotation.z.formatToSecond
                
                self.debugLabel.text = "Position - X: \(positionX) Y: \(positionY) Z: \(positionZ)\nRotation - X: \(rotationX) Y: \(rotationY) Z: \(rotationZ)"
            }
            .disposed(by: disposeBag)
        
        resetButton.rx.tap
            .asObservable()
            .subscribe { [weak self] _ in
                self?.resetButtonTapped()
            }
            .disposed(by: disposeBag)
    }
    
    //MARK: - SetupAR
    private func setupARKit() {
        arView.session.delegate = self
        arView.environment.sceneUnderstanding.options = []
        arView.environment.sceneUnderstanding.options.insert(.occlusion) // Í∞ÄÏÉÅÏò§Î∏åÏ†ùÌä∏Ïùò Í∞ÄÎ†§Ïßê Íµ¨ÌòÑ (Mixed Reality)
        arView.environment.sceneUnderstanding.options.insert(.physics) // Ïã§Ï†ú ÏÑ∏Í≥ÑÏùò 3D Î©îÏãúÎ•º ÌÜµÌïú Î¨ºÎ¶¨ ÏãúÎÆ¨Î†àÏù¥ÏÖò Íµ¨ÌòÑ
        // ÏùºÎ∂Ä Î†åÎçîÎßÅ ÏòµÏÖò ÎπÑÌôúÏÑ±Ìôî(ÌçºÌè¨Î®ºÏä§)
        arView.renderOptions = [.disablePersonOcclusion, .disableDepthOfField, .disableMotionBlur]
        
        arView.addCoaching()
        arView.session.run(viewModel.setupARConfiguration()) // ARSession ÏûêÎèôÏÑ§Ï†ï ÎπÑÌôúÏÑ±Ìôî
        let tapGestureRecognizer = UITapGestureRecognizer(target: self, action: #selector(didTapScreen(_:)))
        arView.addGestureRecognizer(tapGestureRecognizer)
    }
    
    private func resetButtonTapped() {
        let alert = UIAlertController(title: "ÏúÑÏπò Î¶¨ÏÖã", message: "üî•Î¶¨ÏñºÎ¶¨ Î¶¨ÏÖã ÏõêÌï®Ïöî?", preferredStyle: .alert)
        let confirm = UIAlertAction(title: "Î¶¨ÏÖãÍ≥†Í≥†üî•", style: .destructive) { [weak self] _ in
            self?.resetARSession()
        }
        let cancel = UIAlertAction(title: "Îã§Ïãú ÏÉùÍ∞ÅÌïòÍ∏∞", style: .default)
        alert.addAction(confirm)
        alert.addAction(cancel)
        present(alert, animated: true)
    }
    
    private func resetARSession() {

    }
    
    //MARK: - Selector
    @objc func didTapScreen(_ recognizer: UIGestureRecognizer) {
        
        /// 1. Ray-Cast Î∞©ÏãùÏúºÎ°ú ÌÑ∞ÏπòÌïú Ï¢åÌëúÎ°ú Ïã§Ï†ú Í≥µÍ∞Ñ Ï¢åÌëú Ï∞æÍ∏∞
        /// Note: Ray-cast option ".estimatedPlane" with alignment ".any" also takes the mesh into account.
        let tapLocation = recognizer.location(in: arView)
        if let result = arView.raycast(from: tapLocation, allowing: .estimatedPlane, alignment: .any).first {
            
            /// 2. RayÏôÄ ÌëúÎ©¥Ïùò ÍµêÏ∞®Ï†êÏóê 3D Ïò§Î∏åÏ†ùÌä∏ ÏÉùÏÑ±, ARViewÏóê Ï∂îÍ∞Ä
            let resultAnchor = AnchorEntity(world: result.worldTransform)
            resultAnchor.addChild(viewModel.getModelEntity(.cup))
            arView.scene.addAnchor(resultAnchor, removeAfter: 3)

            /// 3. ÌÉ≠Ìïú ÏúÑÏπò Ï£ºÎ≥ÄÏùò ÌëúÎ©¥ Î∂ÑÎ•òÎ•º Ï∞æÍ∏∞
            /// Î∞îÎã•, Î≤Ω, Î¨∏, Ï∞ΩÎ¨∏, ÌÖåÏù¥Î∏î Îì±
            nearbyFaceWithClassification(to: result.worldTransform.position) { (centerOfFace, classification) in
                // ...
                DispatchQueue.main.async {
                    /// 4. ÌòÑÏã§ Í≥µÍ∞ÑÏóê ÌÖçÏä§Ìä∏ Î∞∞Ïπò
                    /// ÏÇ¨Ïö©Ïûê ÏãúÏ†êÏóê Îî∞Îùº Ï°∞Í∏à Ïù¥Îèô, Î©îÏãúÏóê Í∞ÄÎ†§ÏßÄÏßÄ ÏïäÎèÑÎ°ù Ìï®
                    let rayDirection = normalize(result.worldTransform.position - self.arView.cameraTransform.translation)
                    let textPositionInWorldCoordinates = result.worldTransform.position - (rayDirection * 0.1)
                    
                    // 5. ÌäπÏ†ï Î∂ÑÎ•ò ÎÇòÌÉÄÎÇ¥Îäî 3D ÌÖçÏä§Ìä∏ ÏÉùÏÑ±
                    let textEntity = self.generateClassficationTextModel(for: classification)

                    /// 6. ÌÖçÏä§Ìä∏ ÌÅ¨Í∏∞Î•º Ray-Cast Í≤∞Í≥ºÏôÄ Ïπ¥Î©îÎùº ÏÇ¨Ïù¥Ïùò Í±∞Î¶¨Ïóê Îî∞Îùº Ï°∞Ï†àÌï® -> Ìï≠ÏÉÅ Ïä§ÌÅ¨Î¶∞ÏóêÏÑú ÎèôÏùºÌïú ÌÅ¨Í∏∞Î°ú Î≥¥Ïù¥ÎèÑÎ°ù ÏÑ§Ï†ï
                    let raycastDistance = distance(result.worldTransform.position, self.arView.cameraTransform.translation)
                    textEntity.scale = .one * raycastDistance

                    /// 7. 3D ÌÖçÏä§Ìä∏Î•º AR SessionÏóê Ï∂îÍ∞ÄÌïòÍ≥†, ÌÖçÏä§Ìä∏Í∞Ä ÏÇ¨Ïö©ÏûêÎ•º Î∞îÎùºÎ≥¥ÎèÑÎ°ù ÏÑ§Ï†ïÌï®
                    var resultWithCameraOrientation = self.arView.cameraTransform
                    resultWithCameraOrientation.translation = textPositionInWorldCoordinates
                    let textAnchor = AnchorEntity(world: resultWithCameraOrientation.matrix)
                    textAnchor.addChild(textEntity)
                    self.arView.scene.addAnchor(textAnchor, removeAfter: 3)

                    // 8. ÌÉ≠ ÏúÑÏπò Í∑ºÏ≤òÏóê Ïñ¥Îñ§ Î©¥Ïù¥ Í∞êÏßÄÎêòÏóàÎã§Î©¥, Í∑∏ Î©¥Ïùò Ï§ëÏã¨ÏùÑ ÏãúÍ∞ÅÌôîÌï®, Î©¥Ïùò Î∂ÑÎ•òÏóê Îî∞Îùº Îã§Î•∏ ÏÉâÏÉÅ ÏÇ¨Ïö©
                    if let centerOfFace = centerOfFace {
                        let faceAnchor = AnchorEntity(world: centerOfFace)
                        faceAnchor.addChild(self.sphere(radius: 0.01, color: classification.color))
                        self.arView.scene.addAnchor(faceAnchor, removeAfter: 3)
                    }
                }
            }
        }
    }
    
    //MARK: - AR Methods
    func sphere(radius: Float, color: UIColor) -> ModelEntity {
        let sphere = ModelEntity(mesh: .generateSphere(radius: radius), materials: [SimpleMaterial(color: color, isMetallic: false)])
        // Move sphere up by half its diameter so that it does not intersect with the mesh
        sphere.position.y = radius
        return sphere
    }
    
    //MARK: - ÌèâÎ©¥ Ïù∏Ïãù
    func nearbyFaceWithClassification(to location: SIMD3<Float>, completionBlock: @escaping (SIMD3<Float>?, ARMeshClassification) -> Void) {
        /// 1. guard Ïñ∏ÎûòÌïë
        guard let frame = arView.session.currentFrame else {
            completionBlock(nil, .none)
            return
        }

        /// 2. ÌòÑ ÌîÑÎ†àÏûÑÏùò Î™®Îì† ÏïµÏª§Î•º ARMeshAnchorÎ°ú Î≥ÄÌôò
        /// Ï£ºÏñ¥ÏßÑ ÏúÑÏπòÎ°úÎ∂ÄÌÑ∞ Í±∞Î¶¨Ïóê Îî∞Îùº Ï†ïÎ†¨
        /// cutOffDistance - ÎÑàÎ¨¥ Î®º ÏïµÏª§ Ï†úÍ±∞ offset
        var meshAnchors = frame.anchors.compactMap({ $0 as? ARMeshAnchor })
        let cutoffDistance: Float = 4.0
        meshAnchors.removeAll { distance($0.transform.position, location) > cutoffDistance }
        meshAnchors.sort { distance($0.transform.position, location) < distance($1.transform.position, location) }

        DispatchQueue.global().async {
            ///3.  Ï†ïÎ†¨Ìïú AnchorÎì§ÏùÑ forÎ¨∏ ÎèåÎ†§ÏÑú Í≤ÄÏÉâ (ÎπÑÎèôÍ∏∞)
            ///Î∂ÑÎ•òÍ∞Ä ÏûàÎã§Î©¥ ÌôîÎ©¥Ïóê ÌëúÏãú
            for anchor in meshAnchors {
                
                for index in 0..<anchor.geometry.faces.count {
                    // Get the center of the face so that we can compare it to the given location.
                    let geometricCenterOfFace = anchor.geometry.centerOf(faceWithIndex: index)
                    
                    // Convert the face's center to world coordinates.
                    var centerLocalTransform = matrix_identity_float4x4
                    centerLocalTransform.columns.3 = SIMD4<Float>(geometricCenterOfFace.0, geometricCenterOfFace.1, geometricCenterOfFace.2, 1)
                    let centerWorldPosition = (anchor.transform * centerLocalTransform).position
                     
                    let distanceToFace = distance(centerWorldPosition, location)
                    
                    /// 4. ÏÑ†ÌÉùÌïú ÏúÑÏπòÎ°úÎ∂ÄÌÑ∞ 5cm Ïù¥ÎÇ¥ Í±∞Î¶¨Ïóê Î∂ÑÎ•òÎêòÎäî Í≤ÉÏù¥ ÏûàÎã§Î©¥, Í≤∞Í≥º escaping closureÎ°ú Î∞òÌôòÌïòÍ∏∞
                    if distanceToFace <= 0.05 {
                        let classification: ARMeshClassification = anchor.geometry.classificationOf(faceWithIndex: index)
                        completionBlock(centerWorldPosition, classification)
                        return
                    }
                }
            }
            
            /// 5. Ï∞æÏßÄ Î™ªÌñàÎã§Î©¥ (nil, .none) Î∞òÌôòÌïòÍ∏∞
            completionBlock(nil, .none)
        }
    }
    
    func generateClassficationTextModel(for classification: ARMeshClassification) -> ModelEntity {
        // Return cached model if available
        if let model = modelsForClassification[classification] {
            model.transform = .identity
            return model.clone(recursive: true)
        }
        
        // Generate 3D text for the classification
        let lineHeight: CGFloat = 0.05
        let font = MeshResource.Font.systemFont(ofSize: lineHeight)
        let textMesh = MeshResource.generateText(classification.description, extrusionDepth: Float(lineHeight * 0.1), font: font)
        let textMaterial = SimpleMaterial(color: classification.color, isMetallic: true)
        let model = ModelEntity(mesh: textMesh, materials: [textMaterial])
        // Move text geometry to the left so that its local origin is in the center
        model.position.x -= model.visualBounds(relativeTo: nil).extents.x / 2
        // Add model to cache
        modelsForClassification[classification] = model
        return model
    }
    
    private func generateObject(anchor: AnchorEntity) {
        let modelEntity = viewModel.getModelEntity(.cup)
        
        let anchor = AnchorEntity(.plane(.any, classification: .any, minimumBounds: .one))
        anchor.addChild(modelEntity)
        arView.installGestures(.all, for: modelEntity)
        arView.scene.anchors.append(anchor)
    }
    
    //MARK: - UIMethods
    private func setupUI() {
        view.addSubview(arView)
        arView.snp.makeConstraints {
            $0.edges.equalToSuperview()
        }
        
        let scanningDebugLabel = getUITitle(title: "ÎùºÏù¥Îã§ÏÑºÏÑú ÎîîÎ≤ÑÍπÖ")
        
        let scanningDebugStack = UIStackView(arrangedSubviews: [scanningDebugLabel, scanningDebugToggle])
        scanningDebugStack.alignment = .center
        scanningDebugStack.axis = .horizontal
        scanningDebugStack.spacing = 15
        scanningDebugStack.layoutMargins = UIEdgeInsets(top: 0, left: 10, bottom: 0, right: 10)
        scanningDebugStack.isLayoutMarginsRelativeArrangement = true
        
        let yStack = UIStackView(arrangedSubviews: [scanningDebugStack])
        yStack.axis = .vertical
        yStack.spacing = 15
        view.addSubview(yStack)
        yStack.snp.makeConstraints {
            $0.top.trailing.equalTo(view.safeAreaLayoutGuide).inset(10)
            $0.height.equalTo(50)
            yStack.backgroundColor = .black.withAlphaComponent(0.4)
            yStack.layer.cornerRadius = 50 / 2
            yStack.clipsToBounds = true
        }
        
        view.addSubview(debugView)
        debugView.snp.makeConstraints {
            $0.leading.trailing.bottom.equalToSuperview()
            $0.height.equalTo(100)
        }
        
        debugView.addSubview(resetButton)
        resetButton.snp.makeConstraints {
            $0.centerY.equalToSuperview()
            $0.trailing.equalToSuperview().inset(16)
            $0.height.equalTo(60)
            $0.width.equalTo(120)
            resetButton.layer.cornerRadius = 30
            resetButton.clipsToBounds = true
        }
    }
    
    private func getUIButton(title: String) -> UIButton {
        let button = UIButton(type: .system)
        button.setTitle(title, for: .normal)
        button.backgroundColor = .black.withAlphaComponent(0.6)
        button.tintColor = .white
        return button
    }
    
    private func getUITitle(title: String) -> UILabel {
        let label = UILabel()
        label.font = .boldSystemFont(ofSize: 16)
        label.text = title
        label.textAlignment = .center
        label.textColor = .white
        return label
    }
    
}

extension ARViewController: ARSessionDelegate {
    func session(_ session: ARSession, didUpdate frame: ARFrame) {
        if let currentFrame = session.currentFrame {
            viewModel.processARCamera(currentFrame: currentFrame)
        }
    }
    
    func session(_ session: ARSession, didRemove anchors: [ARAnchor]) {
        for anchor in anchors {
            if let planeAnchor = anchor as? ARPlaneAnchor {
                // Remove the ModelEntity for this ARPlaneAnchor
                planeEntities[planeAnchor]?.removeFromParent()
                planeEntities.removeValue(forKey: planeAnchor)
            }
        }
    }
}
